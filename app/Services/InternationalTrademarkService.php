<?php

namespace App\Services;

use App\Models\Country;
use App\Models\Matter;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class InternationalTrademarkService
{
    /**
     * Create national trademark matters from international WO registration
     * 
     * @param Matter $internationalMatter WO trademark matter (parent)
     * @param array $countries Array of ISO country codes
     * @return array Results with created/skipped matters
     */
    public function createCountryMatters(Matter $internationalMatter, array $countries, array $copyOptions = []): array
    {
        $copyOptions = array_merge([
            'actors' => true,
            'classifiers' => true,
            'events' => true,
        ], $copyOptions);

        // Validate international matter
        $validation = $this->validateInternationalMatter($internationalMatter);
        if (!empty($validation['errors'])) {
            throw new \InvalidArgumentException('Invalid international matter: ' . implode(', ', $validation['errors']));
        }

        $results = [
            'created' => [],
            'skipped' => [],
            'errors' => []
        ];

        // Get existing national matters to avoid duplicates
        $existingMatters = $this->getExistingNationalMatters($internationalMatter);
        $existingCountries = $existingMatters->pluck('country')->toArray();

        foreach ($countries as $countryIso) {
            try {
                // Skip if matter already exists for this country
                if (in_array($countryIso, $existingCountries)) {
                    $results['skipped'][] = [
                        'country' => $countryIso,
                        'reason' => 'Matter already exists',
                        'existing_uid' => $existingMatters->where('country', $countryIso)->first()->uid ?? null
                    ];
                    continue;
                }

                // Create national matter
                $nationalMatter = $this->createSingleNationalMatter($internationalMatter, $countryIso, $copyOptions);
                
                $results['created'][] = [
                    'country' => $countryIso,
                    'matter_id' => $nationalMatter->id,
                    'uid' => $nationalMatter->uid
                ];

                Log::info("Created national trademark matter", [
                    'parent_id' => $internationalMatter->id,
                    'parent_uid' => $internationalMatter->uid,
                    'national_id' => $nationalMatter->id,
                    'national_uid' => $nationalMatter->uid,
                    'country' => $countryIso
                ]);

            } catch (\Exception $e) {
                $results['errors'][] = [
                    'country' => $countryIso,
                    'error' => $e->getMessage()
                ];

                Log::error("Failed to create national trademark matter", [
                    'parent_id' => $internationalMatter->id,
                    'country' => $countryIso,
                    'error' => $e->getMessage()
                ]);
            }
        }

        return $results;
    }

    /**
     * Create a single national matter from international trademark
     */
    private function createSingleNationalMatter(Matter $internationalMatter, string $countryIso, array $copyOptions): Matter
    {
        $containerId = $internationalMatter->container_id ?? $internationalMatter->id;

        // Prepare data for new matter (based on storeN pattern)
        $newMatterData = [
            'country' => $countryIso,
            // Intelligent origin logic: set to 'WO' only if parent is from WO or already WO-derived
            'origin' => ($internationalMatter->country === 'WO' || $internationalMatter->origin === 'WO')
                ? 'WO'
                : $internationalMatter->origin,
            'caseref' => $internationalMatter->caseref,
            'idx' => $internationalMatter->idx,
            // suffix is auto-generated by MySQL based on country/origin/type_code/idx
            'category_code' => $internationalMatter->category_code, // Keep TM category
            'type_code' => $internationalMatter->type_code,
            'responsible' => $internationalMatter->responsible,
            'creator' => Auth::user()?->login ?? 'system',
            'expire_date' => $internationalMatter->expire_date,
            'parent_id' => $internationalMatter->id,
            'container_id' => $containerId,
        ];

        // Create new matter
        $nationalMatter = Matter::create($newMatterData);

        // Copy data from parent matter, respecting copy_options
        $this->duplicateMatterData($internationalMatter, $nationalMatter, $copyOptions);

        return $nationalMatter;
    }

    /**
     * Duplicate core matter data from source to target
     *
     * Note: actors and classifiers with shared=1 on the container are automatically
     * inherited via container_id (through DB views). We only copy actors/classifiers
     * that are specific to the source matter (not inherited from container).
     */
    public function duplicateMatterData(Matter $source, Matter $target, array $copyOptions = []): void
    {
        $copyOptions = array_merge([
            'actors' => true,
            'classifiers' => true,
            'events' => true,
        ], $copyOptions);

        DB::transaction(function () use ($source, $target, $copyOptions) {
            // Always create linking events (ENT + PFIL) regardless of copy_options
            $this->copyEvents($source, $target);

            // Only copy actors that are NOT already inherited from the container
            if ($copyOptions['actors']) {
                $this->copyActors($source, $target);
            }

            // Only copy classifiers that are NOT already inherited from the container
            if ($copyOptions['classifiers']) {
                $this->copyClassifiers($source, $target);
            }
        });
    }

    /**
     * Copy events from source to target matter
     */
    private function copyEvents(Matter $source, Matter $target): void
    {
        // Remove the "CRE" event auto-created by the matter_after_insert trigger
        $target->events()->where('code', 'CRE')->delete();

        // Create "parent filed" event linking to international matter
        $target->events()->create([
            'code' => 'PFIL',
            'alt_matter_id' => $source->id
        ]);
    }

    /**
     * Copy actors from source to target matter.
     *
     * Actors with shared=1 on the container are automatically inherited via
     * container_id (DB view MatterActors). We only copy non-shared actors
     * that are specific to the source matter itself.
     */
    private function copyActors(Matter $source, Matter $target): void
    {
        // If the target has a container_id, shared actors from the container
        // are already inherited via the DB view — don't copy them again.
        // Only copy actors that belong directly to the source (not its container)
        // and that are NOT shared (shared ones are inherited).
        $actorsToCheck = $source->actorPivot;

        foreach ($actorsToCheck as $actorLink) {
            // Skip shared actors — they're inherited from the container automatically
            if ($actorLink->shared && $target->container_id) {
                continue;
            }

            // Skip if this exact actor+role already exists on the target
            $exists = $target->actorPivot()
                ->where('actor_id', $actorLink->actor_id)
                ->where('role', $actorLink->role)
                ->exists();

            if ($exists) {
                continue;
            }

            $target->actorPivot()->create([
                'actor_id' => $actorLink->actor_id,
                'role' => $actorLink->role,
                'shared' => $actorLink->shared,
                'display_order' => $actorLink->display_order,
                'actor_ref' => $actorLink->actor_ref,
                'date_start' => $actorLink->date_start,
                'date_end' => $actorLink->date_end,
                'rate' => $actorLink->rate,
                'creator' => Auth::user()?->login ?? 'system'
            ]);
        }
    }

    /**
     * Copy classifiers from source to target matter.
     *
     * Classifiers on the container are automatically inherited via container_id
     * (DB view MatterClassifiers uses IFNULL(container_id, id)). We only copy
     * classifiers that are specific to the source matter itself.
     */
    private function copyClassifiers(Matter $source, Matter $target): void
    {
        // If the target has a container_id, classifiers from the container
        // are already inherited via the DB view — only copy source-specific ones.
        // Only copy classifiers that belong directly to the source (not its container).
        if ($target->container_id && $source->id !== $target->container_id) {
            // Source is not the container — copy its own classifiers
            $classifiers = $source->classifiersNative;
        } elseif ($target->container_id && $source->id === $target->container_id) {
            // Source IS the container — classifiers are inherited, nothing to copy
            return;
        } else {
            // No container — copy all classifiers from source
            $classifiers = $source->classifiersNative;
        }

        foreach ($classifiers as $classifier) {
            // Skip if this exact classifier already exists on the target
            $exists = $target->classifiersNative()
                ->where('type_code', $classifier->type_code)
                ->where('value', $classifier->value)
                ->exists();

            if ($exists) {
                continue;
            }

            $target->classifiersNative()->create([
                'type_code' => $classifier->type_code,
                'value' => $classifier->value,
                'url' => $classifier->url,
                'value_id' => $classifier->value_id,
                'display_order' => $classifier->display_order,
                'lnk_matter_id' => $classifier->lnk_matter_id,
                'creator' => Auth::user()?->login ?? 'system'
            ]);
        }
    }

    /**
     * Get countries available for Madrid Protocol (WO trademarks)
     */
    public function getAvailableCountries(): Collection
    {
        return Country::where('wo', 1)
            ->where('iso', '!=', 'WO') // Exclude WO itself
            ->orderBy('name')
            ->get(['iso', 'name', 'name_FR', 'name_DE']);
    }

    /**
     * Validate that matter is eligible for international trademark automation
     */
    public function validateInternationalMatter(Matter $matter): array
    {
        $errors = [];

        // Must be WO country
        if ($matter->country !== 'WO') {
            $errors[] = 'Matter must be from WO (World Intellectual Property Organization)';
        }

        // Must be trademark category
        if ($matter->category_code !== 'TM') {
            $errors[] = 'Matter must be a trademark (TM category)';
        }

        // Must have filing event
        if (!$matter->filing->exists()) {
            $errors[] = 'Matter must have a filing event';
        }

        // Should have registration for best results
        $hasRegistration = $matter->registration->exists() || $matter->grant->exists();
        $warnings = [];
        if (!$hasRegistration) {
            $warnings[] = 'Matter has no registration event - national matters will be created without registration data';
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'warnings' => $warnings
        ];
    }

    /**
     * Get existing national matters for the international trademark
     */
    public function getExistingNationalMatters(Matter $internationalMatter): Collection
    {
        return Matter::where('parent_id', $internationalMatter->id)
            ->where('category_code', 'TM')
            ->where('country', '!=', 'WO')
            ->get(['id', 'uid', 'country', 'created_at']);
    }

    /**
     * Estimate time and resources needed for creation
     */
    public function estimateCreation(Matter $internationalMatter, array $countries): array
    {
        $existing = $this->getExistingNationalMatters($internationalMatter);
        $existingCountries = $existing->pluck('country')->toArray();
        
        $toCreate = array_diff($countries, $existingCountries);
        $toSkip = array_intersect($countries, $existingCountries);

        return [
            'total_requested' => count($countries),
            'to_create' => count($toCreate),
            'to_skip' => count($toSkip),
            'estimated_time_seconds' => count($toCreate) * 3, // ~3 seconds per matter
            'existing_matters' => $existing->keyBy('country')
        ];
    }

    /**
     * Get countries with Madrid Protocol membership (for validation)
     */
    public function getMadridProtocolCountries(): Collection
    {
        // Return countries that participate in Madrid Protocol
        // This could be extended with actual Madrid member data
        return $this->getAvailableCountries();
    }
}