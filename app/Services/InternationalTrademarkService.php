<?php

namespace App\Services;

use App\Models\Country;
use App\Models\Matter;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class InternationalTrademarkService
{
    /**
     * Create national trademark matters from international WO registration
     * 
     * @param Matter $internationalMatter WO trademark matter (parent)
     * @param array $countries Array of ISO country codes
     * @return array Results with created/skipped matters
     */
    public function createCountryMatters(Matter $internationalMatter, array $countries): array
    {
        // Validate international matter
        $validation = $this->validateInternationalMatter($internationalMatter);
        if (!empty($validation['errors'])) {
            throw new \InvalidArgumentException('Invalid international matter: ' . implode(', ', $validation['errors']));
        }

        $results = [
            'created' => [],
            'skipped' => [],
            'errors' => []
        ];

        // Get existing national matters to avoid duplicates
        $existingMatters = $this->getExistingNationalMatters($internationalMatter);
        $existingCountries = $existingMatters->pluck('country')->toArray();

        foreach ($countries as $countryIso) {
            try {
                // Skip if matter already exists for this country
                if (in_array($countryIso, $existingCountries)) {
                    $results['skipped'][] = [
                        'country' => $countryIso,
                        'reason' => 'Matter already exists',
                        'existing_uid' => $existingMatters->where('country', $countryIso)->first()->uid ?? null
                    ];
                    continue;
                }

                // Create national matter
                $nationalMatter = $this->createSingleNationalMatter($internationalMatter, $countryIso);
                
                $results['created'][] = [
                    'country' => $countryIso,
                    'matter_id' => $nationalMatter->id,
                    'uid' => $nationalMatter->uid
                ];

                Log::info("Created national trademark matter", [
                    'parent_id' => $internationalMatter->id,
                    'parent_uid' => $internationalMatter->uid,
                    'national_id' => $nationalMatter->id,
                    'national_uid' => $nationalMatter->uid,
                    'country' => $countryIso
                ]);

            } catch (\Exception $e) {
                $results['errors'][] = [
                    'country' => $countryIso,
                    'error' => $e->getMessage()
                ];

                Log::error("Failed to create national trademark matter", [
                    'parent_id' => $internationalMatter->id,
                    'country' => $countryIso,
                    'error' => $e->getMessage()
                ]);
            }
        }

        return $results;
    }

    /**
     * Create a single national matter from international trademark
     */
    private function createSingleNationalMatter(Matter $internationalMatter, string $countryIso): Matter
    {
        // Prepare data for new matter (based on storeN pattern)
        $newMatterData = [
            'country' => $countryIso,
            // Intelligent origin logic: set to 'WO' only if parent is from WO or already WO-derived
            'origin' => ($internationalMatter->country === 'WO' || $internationalMatter->origin === 'WO') 
                ? 'WO' 
                : $internationalMatter->origin,
            'caseref' => $internationalMatter->caseref,
            'idx' => $internationalMatter->idx,
            // suffix is auto-generated by MySQL based on country/origin/type_code/idx
            'category_code' => $internationalMatter->category_code, // Keep TM category
            'type_code' => $internationalMatter->type_code,
            'responsible' => $internationalMatter->responsible,
            'creator' => Auth::user()?->login ?? 'system',
            'expire_date' => $internationalMatter->expire_date,
            'parent_id' => $internationalMatter->id,
            'container_id' => $internationalMatter->container_id ?? $internationalMatter->id,
        ];

        // Create new matter
        $nationalMatter = Matter::create($newMatterData);

        // Copy data from parent matter
        $this->duplicateMatterData($internationalMatter, $nationalMatter);

        return $nationalMatter;
    }

    /**
     * Duplicate core matter data from source to target
     */
    public function duplicateMatterData(Matter $source, Matter $target): void
    {
        DB::transaction(function () use ($source, $target) {
            // 1. Copy shared events (adapted from storeN)
            $this->copyEvents($source, $target);

            // 2. Copy actors with their roles (adapted from store method)
            $this->copyActors($source, $target);

            // 3. Copy classifiers (titles, NICE classes, etc.)
            $this->copyClassifiers($source, $target);
        });
    }

    /**
     * Copy events from source to target matter (simplified version for testing)
     */
    private function copyEvents(Matter $source, Matter $target): void
    {
        // For now, only create the mandatory linking events
        // TODO: Add proper event copying after basic creation works
        
        // Create "entered national phase" event (exact pattern from storeN)
        $target->events()->create([
            'code' => 'ENT',
            'event_date' => now()
        ]);

        // Create "parent filed" event linking to international matter (exact pattern from storeN)
        $target->events()->create([
            'code' => 'PFIL',
            'alt_matter_id' => $source->id
        ]);
    }

    /**
     * Copy actors from source to target matter
     */
    private function copyActors(Matter $source, Matter $target): void
    {
        // Get actors from the container if source has one, otherwise from source itself
        $containerMatter = $source->container ?? $source;
        
        if ($containerMatter->actorPivot->count() > 0) {
            foreach ($containerMatter->actorPivot as $actorLink) {
                $target->actorPivot()->create([
                    'actor_id' => $actorLink->actor_id,
                    'role' => $actorLink->role,
                    'shared' => 1, // Mark as shared from parent
                    'display_order' => $actorLink->display_order,
                    'actor_ref' => $actorLink->actor_ref,
                    'date_start' => $actorLink->date_start,
                    'date_end' => $actorLink->date_end,
                    'rate' => $actorLink->rate,
                    'creator' => Auth::user()?->login ?? 'system'
                ]);
            }
        }
    }

    /**
     * Copy classifiers from source to target matter
     */
    private function copyClassifiers(Matter $source, Matter $target): void
    {
        // Copy classifiers from container (main display and regular)
        $containerMatter = $source->container ?? $source;
        
        if ($containerMatter->classifiersNative->count() > 0) {
            $classifiersData = $containerMatter->classifiersNative->map(function ($classifier) {
                return [
                    'type_code' => $classifier->type_code,
                    'value' => $classifier->value,
                    'url' => $classifier->url,
                    'value_id' => $classifier->value_id,
                    'display_order' => $classifier->display_order,
                    'lnk_matter_id' => $classifier->lnk_matter_id,
                    'creator' => Auth::user()?->login ?? 'system'
                ];
            })->toArray();

            $target->classifiersNative()->createMany($classifiersData);
        }
    }

    /**
     * Get countries available for Madrid Protocol (WO trademarks)
     */
    public function getAvailableCountries(): Collection
    {
        return Country::where('wo', 1)
            ->where('iso', '!=', 'WO') // Exclude WO itself
            ->orderBy('name')
            ->get(['iso', 'name', 'name_FR', 'name_DE']);
    }

    /**
     * Validate that matter is eligible for international trademark automation
     */
    public function validateInternationalMatter(Matter $matter): array
    {
        $errors = [];

        // Must be WO country
        if ($matter->country !== 'WO') {
            $errors[] = 'Matter must be from WO (World Intellectual Property Organization)';
        }

        // Must be trademark category
        if ($matter->category_code !== 'TM') {
            $errors[] = 'Matter must be a trademark (TM category)';
        }

        // Must have filing event
        if (!$matter->filing->exists()) {
            $errors[] = 'Matter must have a filing event';
        }

        // Should have registration for best results
        $hasRegistration = $matter->registration->exists() || $matter->grant->exists();
        $warnings = [];
        if (!$hasRegistration) {
            $warnings[] = 'Matter has no registration event - national matters will be created without registration data';
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'warnings' => $warnings
        ];
    }

    /**
     * Get existing national matters for the international trademark
     */
    public function getExistingNationalMatters(Matter $internationalMatter): Collection
    {
        return Matter::where('parent_id', $internationalMatter->id)
            ->where('category_code', 'TM')
            ->where('country', '!=', 'WO')
            ->get(['id', 'uid', 'country', 'created_at']);
    }

    /**
     * Estimate time and resources needed for creation
     */
    public function estimateCreation(Matter $internationalMatter, array $countries): array
    {
        $existing = $this->getExistingNationalMatters($internationalMatter);
        $existingCountries = $existing->pluck('country')->toArray();
        
        $toCreate = array_diff($countries, $existingCountries);
        $toSkip = array_intersect($countries, $existingCountries);

        return [
            'total_requested' => count($countries),
            'to_create' => count($toCreate),
            'to_skip' => count($toSkip),
            'estimated_time_seconds' => count($toCreate) * 3, // ~3 seconds per matter
            'existing_matters' => $existing->keyBy('country')
        ];
    }

    /**
     * Get countries with Madrid Protocol membership (for validation)
     */
    public function getMadridProtocolCountries(): Collection
    {
        // Return countries that participate in Madrid Protocol
        // This could be extended with actual Madrid member data
        return $this->getAvailableCountries();
    }
}